---
title: Seagrass mapping in two mudflats in the Auray River
subtitle: About a rapid evolution of seagrasses
author:
  - name: Simon Oiry
    email: oirysimon@gmail.com
    orcid: 0000-0001-7161-5246
    affiliations: 
        - id: ISOMER
          name: Nantes Université, UR 2160, F-44000 Nantes, France
          department: Institut des Substances et Organismes de la Mer, ISOMer
          address: 2 chemin de la houssinière
          city: Nantes
          state: France
          postal-code: 44300
    attributes:
        corresponding: true
  - name: Bede Ffinian Rowe Davies
    email: bedeffinian@gmail.com
    orcid: 0000-0001-6462-4347
    affiliations: 
        - id: ISOMER
          name: Nantes Université, UR 2160, F-44000 Nantes, France
          department: Institut des Substances et Organismes de la Mer, ISOMer
          address: 2 chemin de la houssinière
          city: Nantes
          state: France
          postal-code: 44300
    attributes:
        corresponding: true
abstract: |
  Maps of seagrass in two sites in the Auray River. These two sites were studied by Maxime Daviray during his PhD. Seagrass appeared very quickly during his PhD. This work aims to describe this rapid evolution of seagrasses.
keywords: 
  - Remote Sensing
  - Sentinel-2
  - Seagrass
date: last-modified
bibliography: library.bib
number-sections: true
notebook-links: false
editor_options: 
  chunk_output_type: console
---

```{r library}
#| cache: false
#| echo: false
#| warning: false
#| eval: true

library(tidyverse)
library(tidyterra)
library(terra)
library(patchwork)
library(png)
library(gridExtra)

```

The data and scripts used for this work can be found [here](https://github.com/SigOiry/Seagrass_maps_Maxime).

# Materials & Methods

## Seagrass mapping using Sentinel-2

To map the seagrass extent over time, the Sentinel-2 constellation has been used. Level-2 images, which are already orthorectified and atmospherically corrected using Sen2Cor, have been downloaded using the Copernicus Platform [@Copernicus_Sentinel]. One low tide, cloud-free image per year, nearest to the period of maximum seagrass biomass at this latitude, has been used. A total of 8 images have beed used (@tbl-tide-data).

| Acquisition Date (UTC) | Low Tide Time (UTC) | Time Difference with Low tide |
|:---------------------:|:------------------:|:---------------------------:|
|    2016-11-03 11:12    |       12 : 08       |          \+ 00 : 56           |
|    2017-10-04 11:08    |       09 : 09       |          \- 01 : 59           |
|    2018-09-29 11:08    |       12 : 43       |          \+ 01 : 35           |
|    2019-09-14 11:06    |       10 : 28       |          \+ 00 : 38           |
|    2020-08-04 11:06    |       10 : 45       |          \+ 00 : 21           |
|    2021-10-08 11:09    |       11 : 18       |          \- 00 : 09           |
|    2022-08-29 11:06    |       11 : 27       |          \- 00 : 21           |
|    2023-09-03 11:06    |       12 : 28       |          \- 01 : 22           |

: Acquisition dates of Sentinel-2 images used to map seagrass in the Auray River. Tide times were retrieved from the SHOM and correspond to the tides at the Locmariaquer tide gauge, situated approximately 2 km from the study sites. {#tbl-tide-data}

The *Intertidal Classification of Europe: Categorising Reflectance of Emerged Areas of Marine vegetation with Sentinel-2* model (ICE CREAMS, @Davies2024), a neural network classifier designed to identify and discriminate intertidal vegetation in Europe, has been applied to each Sentinel-2 image. Pixels of the Magnoliopsida class (seagrasses) have been isolated, and the Normalized Difference Vegetation Index (NDVI, @rouse1974monitoring), a commonly used remote sensing biomass proxy for vegetation, has been employed. The equation of @zoffoli2020sentinel have been used to transform NDVI values into Seagrass Percent Cover ([@eq-std]). SPC values below 20%, corresponding to low biomass pixel, with a high risk of confusion with other vegetation classes, have been remove from the rest of the analysis.

$$
SPC = 172.06 \times NDVI - 22.18
$$ {#eq-std}

Maps and analysis have then been performed using the *Terra* package of R, in a *Tidyverse* workflow [@hijmans2023terra ; @wickham2017easily]. 

# Results

## Evolution of the spatial distribution of seagrasses over time

```{r maps Fig1}
#| cache: false
#| echo: false
#| warning: false
#| eval: false

rgb_list <- list.files("Data/RGB/", pattern = ".tif", recursive = TRUE, full.names = TRUE) %>%
  as_tibble() %>% 
  rename(path_rgb = "value") %>%  
  mutate(name = gsub(".*/","",path_rgb),                 # Extract the filename
         year = substr(name,1,4)) %>% 
  dplyr::select(-name)

img_list <- list.files("Data/ICECREAMS/", pattern = ".tif", recursive = TRUE, full.names = TRUE) %>% 
  as_tibble() %>% 
  rename(path_pred = "value") %>% 
  mutate(name = gsub(".*/","",path_pred),                 # Extract the filename
         year = substr(name,12,15),                  # Extract the year from the filename
         date = as.POSIXct(substr(name,12,19), format = "%Y%m%d")) %>% 
  left_join(rgb_list, by = "year")



# Extract and format the date
mask <- "Data/mask/Intertidal_mask_Auray.shp" %>% 
  vect()

for (i in 1:nrow(img_list)) {
  
  pred <- img_list$path_pred[i] %>% 
    rast(lyrs = 5) %>% 
    mask(mask) %>% 
    as.data.frame(xy=T) %>% 
    mutate(SPC20Unknown = case_when(SPC20Unknown < 20 ~ NA,
                     T ~ SPC20Unknown))
    
  rgb <- img_list$path_rgb[i] %>% 
    rast()

    for(site_i in 1:length(unique(mask$Site_Name))){
      
      
      site <- unique(mask$Site_Name)[site_i]
    
      # Extract the mask for the current site
      ext <- mask[which(mask$Site_Name == site)] %>% 
        ext()
      
      resize_x <- (as.numeric(ext[2])- as.numeric(ext[1]))*0.2
      resize_y <- (as.numeric(ext[4])- as.numeric(ext[3]))*0.15

      text_position_x <- as.numeric(ext[1] + ((as.numeric(ext[2])- as.numeric(ext[1]))*0.1))
      text_position_y <- as.numeric(ext[3] - ((as.numeric(ext[4])- as.numeric(ext[3]))*0.12))

      
      plot <- ggplot()+
        geom_spatraster_rgb(data = rgb,
                            max_col_value = 0.8)+
        coord_sf(xlim = c(ext[1]-resize_x, ext[2]+resize_x),
                ylim = c(ext[3]-resize_y, ext[4]+resize_y)) +
        # geom_text(aes(x = text_position_x, y = text_position_y, label = img_list$year[i]), color = "white" , size = 5)+
  
        scale_fill_viridis_c(na.value = "transparent")+
        theme(axis.text = element_blank(),
              axis.title = element_blank(),
              axis.ticks = element_blank(),
              plot.margin = margin(0, 0, 0, 0, "mm"))
    
      if(site_i == 1){
        a <- plot +
          geom_tile(data = pred, aes(x = x, y = y, fill = SPC20Unknown), show.legend = F) +  # Use a continuous color scale and make NA values transparent

          geom_text(aes(x = 503360, y = 5274145, label = "Fort Espagnol" ), color = "white" , size = 7) +
          geom_text(aes(x = 503301.7, y = 5273133, label = img_list$year[i]), color = "white" , size = 7)
  
      }else{
        b = plot +
          geom_text(aes(x = 502650, y = 5271835, label = "Kerouarc'h" ), color = "white" , size = 7)
        
        if(img_list$year[i]=="2023"){
         b = b + geom_tile(data = pred, aes(x = x, y = y, fill = SPC20Unknown))  +
            labs(fill = "SPC (%)")+
            theme(legend.position = c(.9,.85),
                  legend.background = element_rect(fill=scales::alpha('white', 0.4)),
                  legend.text = element_text(size = 15),
                  legend.title = element_text(size = 18,margin = margin(b = 15)),
                  legend.key.size = unit(0.7,"cm")
                  )

        }else{
          b = b + geom_tile(data = pred, aes(x = x, y = y, fill = SPC20Unknown), show.legend = F)  # Use a continuous color scale and make NA values transparent

        }
      }
      
      
    }
  
  patchwork <- a+b
  ggsave(paste0("Output/Figs/maps/",img_list$year[i],"_maps.png"),patchwork, width = 832*3, height = 759*3, units = "px" )
}


read_png_as_ggplot <- function(file_path) {
  img <- readPNG(file_path)
  img_grob <- grid::rasterGrob(img, interpolate = TRUE)
   return(ggplot() +
    annotation_custom(img_grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf) +
    theme_void())
}

png_files <- list.files(path = "Output/Figs/maps", pattern = "*.png", full.names = TRUE)

# Create a list of ggplot objects
plot_list <- lapply(png_files, read_png_as_ggplot)

# Combine plots into one
combined_plot <- do.call(grid.arrange, c(plot_list, ncol = 4))  # Change ncol to adjust the number of columns

  ggsave("Output/Figs/test.png",combined_plot, width = 2620, height = 2620/2.3, units = "px")

```



